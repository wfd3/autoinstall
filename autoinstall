#!/bin/bash

#
# Install packages from a list of packages and manage package repository dependencies
#
# This script reads a list of packages from a file and installs them using apt. 
# The file can contain package names, URLs, scripts, and directives to add repositories.
# 
# Usage: autoinstall [-n] [-p] <filename>
#   -n   Dry run (do not actually install packages)
#   -p   Preserve the temporary working directory
#   -h   Display this help message and exit
# 
# Examples:
#   autoinstall -n package_list.cfg
#   autoinstall -p package_list.cfg
# 
# The package list file can contain the following types of lines:
#   - Package names: The script will install the package using apt
#   - Directives: These lines contain a package name followed by a colon and a list of directives
#     - deb: Add a deb source to /etc/apt/sources.list.d/... file
#     - repo: Add a repository using add-apt-repository
#     - url: Download a file from a URL and install it
#     - script: Run a script from the package list
#     - source: Alias for deb directive
#
# Example package list file:
#   # Install a package
#   package-name
#
#   # Add a package repository with add-apt-repository and install a package
#   package-name: repo: ppa:example/ppa
#
#   # Run commands and then install a package
#   package-name: script: echo "Hello, World!"
#
#   # Download a file from a URL and then install it
#   package-name: url: https://example.com/file.deb
#
#   # Add a apt source to /etc/apt/sources.list.d and install a package
#   package-name: deb: /etc/apt/sources.list.d/example.list

# Command line flags
dry_run=false
preserve_working_dir=false
filename=""
temp_dir=""

usage() {
  exit_code=$1
  cat <<EOF
$0: Installs packages and manages package repository dependencies

Usage: $0 [OPTIONS] <filename>

Options:
  -n   Dry run (do not actually install packages)
  -p   Preserve the temporary working directory
  -h   Display this help message and exit

Examples:
  $0 -n package_list.txt
  $0 -p package_list.txt
EOF
  bail $exit_code
}

# Exit and clean up temp directory
bail() {
  exit_code=$1

  cd "$original_dir"

  if [[ "$preserve_working_dir" == "false" ]] ; then
    rm -rf "$temp_dir"
  fi

  exit $exit_code
}

# Parse command line arguments and sanitize input path
parse_command_line() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -n)
        dry_run=true
        shift
        ;;
      -p)
        preserve_working_dir=true
        shift
        ;;
      -h)
        usage 0
        ;;
      -*)
        echo "Unknown option: $1"
        usage 1
        ;;
      *)
        break
        ;;
    esac
  done

  # Check if a filename is provided
  if [[ -z "$1" ]]; then
    echo "Usage: $0 [-n] [-p] <filename>"
    bail 1
  fi

  filename=$(realpath "$1")
  if [[ ! -r "$filename" ]]; then
    echo "File '$filename' does not exist or is not readable."
    bail 1
  fi
}

rootcheck() {
  if [[ $EUID -ne 0 && "$dry_run" == "false" ]]; then
    echo "Error: $0 must be run as root."
    bail 1
  fi
}

# Save the current directory & create a working directory
mktmpdir() {
  original_dir=$(pwd)
  script_dir=$(realpath "$0")
  temp_dir=$(mktemp -d "${script_dir}_XXXXXX")

  if [[ -z "$temp_dir" || ! -d "$temp_dir" ]]; then
    echo "Error creating temporary directory."
    bail 1
  fi

  cd "$temp_dir"
}

# Load the list of installed packages
load_package_list() {
  installed_packages=($(apt list --installed 2>/dev/null | awk '{print $1}' | cut -d '/' -f1))
}

# Check if a package is installed
is_package_installed() {
  local package="$1"

  if [[ " ${installed_packages[@]} " =~ " ${package} " ]]; then
    return 0 
  fi
  return 1
}

# Check if a file is a Debian package
is_deb_package() {
  local filename="$1"

  # Check if the file exists and is a regular file
  if [[ ! -f "$filename" ]]; then
    echo "File $filename does not exist or is not a regular file."
    return 1
  fi

  # Check the magic number using file command
  local file_type=$(file -b "$filename")

  # Use regex to match "Debian binary package" variations
  if [[ "$file_type" =~ ^Debian\ binary\ package.*$ ]]; then
    echo "Debian binary package"
    return 0
  fi

  # Check for "ar archive" (for older Debian packages)
  if [[ "$file_type" == "ar archive" ]]; then
    echo "Debian binary package (old format)"
    return 0
  fi

  return 1
}

# Add a deb source to /etc/apt/sources.list.d/... file
add_deb_source() {
  line=$1
  IFS=' ' read -r filename string <<< "$line"

  # Check if the filename is a full path
  dirname=$(dirname "$filename")
  if [[ "$dirname" != "/etc/apt/sources.list.d" ]]; then
    filename=$(echo "/etc/apt/sources.list.d/$filename")
  fi

  if $dry_run; then
    echo "Would add '$string' to $filename"
    return
  fi

  if [[ ! -f "$filename" ]]; then
    echo "$string" > "$filename"
    echo "Added package source in $filename"
  fi
}

# Add a repository using add-apt-repository
add_repo() {
  repo=$1

  if $dry_run; then
    echo "Would add repository: '$repo'"
    return
  fi

  add-apt-repository -y "$repo"
  if [[ $? -ne 0 ]]; then
    echo "Error adding repository: $repo. Exiting."
    bail 1
  fi

  echo "Added repository: $repo, running 'apt update'"
  apt update >& /dev/null
  if [[ $? -ne 0 ]]; then
    echo "Error updating package list. Exiting."
    bail 1
  fi
}

# Download a file from a URL and install it 
download_from_url() {
  local original_url="$1"

  # Get final URL after redirects, removing trailing CRLF
  local final_url=$(curl -sL -I "$original_url" | grep "^location:" | cut -d ' ' -f 2 | tr -d '\r\n')
  if [[ -z "$final_url" ]]; then
    final_url="$original_url"
  fi

  # Extract filename from the final URL
  local filename=$(basename "$final_url")

  if $dry_run; then
    echo "Would download file: $filename from URL: $final_url"
    return
  fi

  # Download the file with the extracted filename
  echo "Downloading $final_url"
  echo "    to file $filename"
  curl -L -o "$filename" "$original_url"
  local return_code=$?

  if [[ $return_code -ne 0 ]]; then
    echo "Error downloading file from $original_url."
    echo "Curl returned exit code: $return_code"
    bail 1
  fi

  if ! is_deb_package "$filename"; then
    echo "Error: Downloaded file is not a Debian package. Exiting."
    bail 1
  fi

  echo "Installing file: $filename"
  dpkg -i "$filename"
  if [[ $? -ne 0 ]]; then
    echo "Error installing $filename. Exiting."
    bail 1
  fi
}

# Install a package using apt
apt_install() {
  package=$1
  # Trim leading and trailing whitespace
  package=$(echo "$package" | xargs)

  # Check if the package is already installed
  if is_package_installed $package; then
    echo "Already installed: $package"
    return
  fi

  if $dry_run; then
    echo "Would install: $package"
    return
  fi

  echo "Installing: $package"
  apt -y install "$package"
  if [[ $? -ne 0 ]]; then
    echo "Error installing $package. Exiting."
    bail 1
  fi
}

# Run a script from the package list
run_script() {
  script=$1

  # Trim leading and trailing whitespace
  script=$(echo "$script" | xargs)

  if $dry_run; then
    echo "Would run script: $script"
    return
  fi

  echo "Running script: $script"
  eval "$script"
  if [[ $? -ne 0 ]]; then
    echo "Error running script:"
    echo "  $script"
    echo "Exiting."
    bail 1
  fi
}

# Handle directives in the package list and, if that succeeds, install the package
handle_directives() {
  line=$1
  IFS=':' read -r package rest <<< "$line"

  if is_package_installed $package; then
    echo "Already installed: $package"
    return
  fi

  # Handle any directives associated with this package
  IFS=';' read -ra directives <<< $rest
  for d in "${directives[@]}"; do
    # Split the line at the first colon
    IFS=':' read -r directive content <<< "$d"
    # Remove leading/trailing whitespace
    directive=$(echo "$directive" | xargs)
    content=$(echo "$content" | xargs)

    case "$directive" in
      deb)
        add_deb_source "$content"
        ;;
      repo)
        add_repo "$content"
        ;;
      url)
        download_from_url "$content"
        ;;
      script)
        run_script "$content"
        ;;
      source)
        add_deb_source "$content"
        ;;
      *)
        echo "Unknown directive: '$directive'"
        bail 1
        ;;
    esac
  done

  apt_install $package
}

# Main function
main() {
  parse_command_line "$@"
  mktmpdir
  rootcheck
  load_package_list

  # Read the file line by line
  while IFS= read -r line; do
    # Handle backslash line continuation 
    while [[ "$line" =~ \\$ ]]; do
      read -r next_line
      line="${line%\\}"  # Remove the trailing backslash
      line="${line}${next_line}" 
    done

    # Skip empty lines and comments
    if [[ -z "$line" || "$line" =~ ^# ]]; then
      continue
    fi

    handle_directives "$line"

  done < "$filename"

  echo "Installation complete."
  bail 0
}

trap 'bail 1' INT TERM
main "$@"
